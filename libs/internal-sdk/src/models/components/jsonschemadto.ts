/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  JsonSchemaFormatEnum,
  JsonSchemaFormatEnum$inboundSchema,
  JsonSchemaFormatEnum$outboundSchema,
} from "./jsonschemaformatenum.js";
import {
  JsonSchemaTypeEnum,
  JsonSchemaTypeEnum$inboundSchema,
  JsonSchemaTypeEnum$outboundSchema,
} from "./jsonschematypeenum.js";

/**
 * Default value
 */
export type Default = string | number | boolean;

/**
 * Const value (exact match required)
 */
export type Const = {};

/**
 * Schema for array items
 */
export type Items = JSONSchemaDto;

export type Properties = JSONSchemaDto;

/**
 * Additional properties schema
 */
export type AdditionalProperties = JSONSchemaDto | boolean;

export type AllOf = JSONSchemaDto;

export type AnyOf = JSONSchemaDto;

export type OneOf = JSONSchemaDto;

/**
 * Schema must not match (not)
 */
export type Not = JSONSchemaDto;

/**
 * Conditional validation schema (if condition)
 */
export type If = JSONSchemaDto;

/**
 * Schema to apply if "if" condition is true
 */
export type Then = JSONSchemaDto;

/**
 * Schema to apply if "if" condition is false
 */
export type Else = JSONSchemaDto;

export type DependentSchemas = JSONSchemaDto;

/**
 * Content schema for specific types
 */
export type ContentSchema = JSONSchemaDto;

export type Examples = {};

export type JSONSchemaDto = {
  /**
   * JSON Schema type
   */
  type?: JsonSchemaTypeEnum | undefined;
  /**
   * Format validation for strings
   */
  format?: JsonSchemaFormatEnum | undefined;
  /**
   * Title of the schema
   */
  title?: string | undefined;
  /**
   * Description of the schema
   */
  description?: string | undefined;
  /**
   * Default value
   */
  default?: string | number | boolean | undefined;
  /**
   * Const value (exact match required)
   */
  const?: Const | undefined;
  /**
   * Minimum value for numbers
   */
  minimum?: number | undefined;
  /**
   * Maximum value for numbers
   */
  maximum?: number | undefined;
  /**
   * Exclusive minimum
   */
  exclusiveMinimum?: boolean | undefined;
  /**
   * Exclusive maximum
   */
  exclusiveMaximum?: boolean | undefined;
  /**
   * Minimum length for strings
   */
  minLength?: number | undefined;
  /**
   * Maximum length for strings
   */
  maxLength?: number | undefined;
  /**
   * Regular expression pattern
   */
  pattern?: string | undefined;
  /**
   * Minimum number of items in array
   */
  minItems?: number | undefined;
  /**
   * Maximum number of items in array
   */
  maxItems?: number | undefined;
  /**
   * Items must be unique
   */
  uniqueItems?: boolean | undefined;
  /**
   * Schema for array items
   */
  items?: JSONSchemaDto | undefined;
  /**
   * Required properties for object
   */
  required?: Array<string> | undefined;
  /**
   * Object properties
   */
  properties?: { [k: string]: JSONSchemaDto } | undefined;
  /**
   * Additional properties schema
   */
  additionalProperties?: JSONSchemaDto | boolean | undefined;
  /**
   * Enumeration of possible values
   */
  enum?: Array<string> | undefined;
  /**
   * Combination of schemas (allOf)
   */
  allOf?: Array<JSONSchemaDto> | undefined;
  /**
   * At least one schema must match (anyOf)
   */
  anyOf?: Array<JSONSchemaDto> | undefined;
  /**
   * Only one schema must match (oneOf)
   */
  oneOf?: Array<JSONSchemaDto> | undefined;
  /**
   * Schema must not match (not)
   */
  not?: JSONSchemaDto | undefined;
  /**
   * Conditional validation schema (if condition)
   */
  if?: JSONSchemaDto | undefined;
  /**
   * Schema to apply if "if" condition is true
   */
  then?: JSONSchemaDto | undefined;
  /**
   * Schema to apply if "if" condition is false
   */
  else?: JSONSchemaDto | undefined;
  /**
   * Content encoding (e.g., base64)
   */
  contentEncoding?: string | undefined;
  /**
   * Content media type
   */
  contentMediaType?: string | undefined;
  /**
   * Dependent required properties
   */
  dependentRequired?: { [k: string]: Array<string> } | undefined;
  /**
   * Dependent schemas
   */
  dependentSchemas?: { [k: string]: JSONSchemaDto } | undefined;
  /**
   * JSON Schema version
   */
  dollarSchema?: string | undefined;
  /**
   * Unique identifier for the schema
   */
  dollarId?: string | undefined;
  /**
   * Content schema for specific types
   */
  contentSchema?: JSONSchemaDto | undefined;
  /**
   * Example values
   */
  examples?: Array<Examples> | undefined;
  /**
   * Minimum number of decimal places
   */
  multipleOf?: number | undefined;
};

/** @internal */
export const Default$inboundSchema: z.ZodType<Default, z.ZodTypeDef, unknown> =
  z.union([z.string(), z.number(), z.boolean()]);

/** @internal */
export type Default$Outbound = string | number | boolean;

/** @internal */
export const Default$outboundSchema: z.ZodType<
  Default$Outbound,
  z.ZodTypeDef,
  Default
> = z.union([z.string(), z.number(), z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Default$ {
  /** @deprecated use `Default$inboundSchema` instead. */
  export const inboundSchema = Default$inboundSchema;
  /** @deprecated use `Default$outboundSchema` instead. */
  export const outboundSchema = Default$outboundSchema;
  /** @deprecated use `Default$Outbound` instead. */
  export type Outbound = Default$Outbound;
}

export function defaultToJSON(value: Default): string {
  return JSON.stringify(Default$outboundSchema.parse(value));
}

export function defaultFromJSON(
  jsonString: string,
): SafeParseResult<Default, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Default$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Default' from JSON`,
  );
}

/** @internal */
export const Const$inboundSchema: z.ZodType<Const, z.ZodTypeDef, unknown> = z
  .object({});

/** @internal */
export type Const$Outbound = {};

/** @internal */
export const Const$outboundSchema: z.ZodType<
  Const$Outbound,
  z.ZodTypeDef,
  Const
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Const$ {
  /** @deprecated use `Const$inboundSchema` instead. */
  export const inboundSchema = Const$inboundSchema;
  /** @deprecated use `Const$outboundSchema` instead. */
  export const outboundSchema = Const$outboundSchema;
  /** @deprecated use `Const$Outbound` instead. */
  export type Outbound = Const$Outbound;
}

export function constToJSON(value: Const): string {
  return JSON.stringify(Const$outboundSchema.parse(value));
}

export function constFromJSON(
  jsonString: string,
): SafeParseResult<Const, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Const$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Const' from JSON`,
  );
}

/** @internal */
export const Items$inboundSchema: z.ZodType<Items, z.ZodTypeDef, unknown> = z
  .lazy(() => JSONSchemaDto$inboundSchema);

/** @internal */
export type Items$Outbound = JSONSchemaDto$Outbound;

/** @internal */
export const Items$outboundSchema: z.ZodType<
  Items$Outbound,
  z.ZodTypeDef,
  Items
> = z.lazy(() => JSONSchemaDto$outboundSchema);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Items$ {
  /** @deprecated use `Items$inboundSchema` instead. */
  export const inboundSchema = Items$inboundSchema;
  /** @deprecated use `Items$outboundSchema` instead. */
  export const outboundSchema = Items$outboundSchema;
  /** @deprecated use `Items$Outbound` instead. */
  export type Outbound = Items$Outbound;
}

export function itemsToJSON(items: Items): string {
  return JSON.stringify(Items$outboundSchema.parse(items));
}

export function itemsFromJSON(
  jsonString: string,
): SafeParseResult<Items, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Items$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Items' from JSON`,
  );
}

/** @internal */
export const Properties$inboundSchema: z.ZodType<
  Properties,
  z.ZodTypeDef,
  unknown
> = z.lazy(() => JSONSchemaDto$inboundSchema);

/** @internal */
export type Properties$Outbound = JSONSchemaDto$Outbound;

/** @internal */
export const Properties$outboundSchema: z.ZodType<
  Properties$Outbound,
  z.ZodTypeDef,
  Properties
> = z.lazy(() => JSONSchemaDto$outboundSchema);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Properties$ {
  /** @deprecated use `Properties$inboundSchema` instead. */
  export const inboundSchema = Properties$inboundSchema;
  /** @deprecated use `Properties$outboundSchema` instead. */
  export const outboundSchema = Properties$outboundSchema;
  /** @deprecated use `Properties$Outbound` instead. */
  export type Outbound = Properties$Outbound;
}

export function propertiesToJSON(properties: Properties): string {
  return JSON.stringify(Properties$outboundSchema.parse(properties));
}

export function propertiesFromJSON(
  jsonString: string,
): SafeParseResult<Properties, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Properties$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Properties' from JSON`,
  );
}

/** @internal */
export const AdditionalProperties$inboundSchema: z.ZodType<
  AdditionalProperties,
  z.ZodTypeDef,
  unknown
> = z.union([z.lazy(() => JSONSchemaDto$inboundSchema), z.boolean()]);

/** @internal */
export type AdditionalProperties$Outbound = JSONSchemaDto$Outbound | boolean;

/** @internal */
export const AdditionalProperties$outboundSchema: z.ZodType<
  AdditionalProperties$Outbound,
  z.ZodTypeDef,
  AdditionalProperties
> = z.union([z.lazy(() => JSONSchemaDto$outboundSchema), z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AdditionalProperties$ {
  /** @deprecated use `AdditionalProperties$inboundSchema` instead. */
  export const inboundSchema = AdditionalProperties$inboundSchema;
  /** @deprecated use `AdditionalProperties$outboundSchema` instead. */
  export const outboundSchema = AdditionalProperties$outboundSchema;
  /** @deprecated use `AdditionalProperties$Outbound` instead. */
  export type Outbound = AdditionalProperties$Outbound;
}

export function additionalPropertiesToJSON(
  additionalProperties: AdditionalProperties,
): string {
  return JSON.stringify(
    AdditionalProperties$outboundSchema.parse(additionalProperties),
  );
}

export function additionalPropertiesFromJSON(
  jsonString: string,
): SafeParseResult<AdditionalProperties, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AdditionalProperties$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AdditionalProperties' from JSON`,
  );
}

/** @internal */
export const AllOf$inboundSchema: z.ZodType<AllOf, z.ZodTypeDef, unknown> = z
  .lazy(() => JSONSchemaDto$inboundSchema);

/** @internal */
export type AllOf$Outbound = JSONSchemaDto$Outbound;

/** @internal */
export const AllOf$outboundSchema: z.ZodType<
  AllOf$Outbound,
  z.ZodTypeDef,
  AllOf
> = z.lazy(() => JSONSchemaDto$outboundSchema);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AllOf$ {
  /** @deprecated use `AllOf$inboundSchema` instead. */
  export const inboundSchema = AllOf$inboundSchema;
  /** @deprecated use `AllOf$outboundSchema` instead. */
  export const outboundSchema = AllOf$outboundSchema;
  /** @deprecated use `AllOf$Outbound` instead. */
  export type Outbound = AllOf$Outbound;
}

export function allOfToJSON(allOf: AllOf): string {
  return JSON.stringify(AllOf$outboundSchema.parse(allOf));
}

export function allOfFromJSON(
  jsonString: string,
): SafeParseResult<AllOf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AllOf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AllOf' from JSON`,
  );
}

/** @internal */
export const AnyOf$inboundSchema: z.ZodType<AnyOf, z.ZodTypeDef, unknown> = z
  .lazy(() => JSONSchemaDto$inboundSchema);

/** @internal */
export type AnyOf$Outbound = JSONSchemaDto$Outbound;

/** @internal */
export const AnyOf$outboundSchema: z.ZodType<
  AnyOf$Outbound,
  z.ZodTypeDef,
  AnyOf
> = z.lazy(() => JSONSchemaDto$outboundSchema);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AnyOf$ {
  /** @deprecated use `AnyOf$inboundSchema` instead. */
  export const inboundSchema = AnyOf$inboundSchema;
  /** @deprecated use `AnyOf$outboundSchema` instead. */
  export const outboundSchema = AnyOf$outboundSchema;
  /** @deprecated use `AnyOf$Outbound` instead. */
  export type Outbound = AnyOf$Outbound;
}

export function anyOfToJSON(anyOf: AnyOf): string {
  return JSON.stringify(AnyOf$outboundSchema.parse(anyOf));
}

export function anyOfFromJSON(
  jsonString: string,
): SafeParseResult<AnyOf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AnyOf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AnyOf' from JSON`,
  );
}

/** @internal */
export const OneOf$inboundSchema: z.ZodType<OneOf, z.ZodTypeDef, unknown> = z
  .lazy(() => JSONSchemaDto$inboundSchema);

/** @internal */
export type OneOf$Outbound = JSONSchemaDto$Outbound;

/** @internal */
export const OneOf$outboundSchema: z.ZodType<
  OneOf$Outbound,
  z.ZodTypeDef,
  OneOf
> = z.lazy(() => JSONSchemaDto$outboundSchema);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OneOf$ {
  /** @deprecated use `OneOf$inboundSchema` instead. */
  export const inboundSchema = OneOf$inboundSchema;
  /** @deprecated use `OneOf$outboundSchema` instead. */
  export const outboundSchema = OneOf$outboundSchema;
  /** @deprecated use `OneOf$Outbound` instead. */
  export type Outbound = OneOf$Outbound;
}

export function oneOfToJSON(oneOf: OneOf): string {
  return JSON.stringify(OneOf$outboundSchema.parse(oneOf));
}

export function oneOfFromJSON(
  jsonString: string,
): SafeParseResult<OneOf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OneOf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OneOf' from JSON`,
  );
}

/** @internal */
export const Not$inboundSchema: z.ZodType<Not, z.ZodTypeDef, unknown> = z.lazy(
  () => JSONSchemaDto$inboundSchema
);

/** @internal */
export type Not$Outbound = JSONSchemaDto$Outbound;

/** @internal */
export const Not$outboundSchema: z.ZodType<Not$Outbound, z.ZodTypeDef, Not> = z
  .lazy(() => JSONSchemaDto$outboundSchema);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Not$ {
  /** @deprecated use `Not$inboundSchema` instead. */
  export const inboundSchema = Not$inboundSchema;
  /** @deprecated use `Not$outboundSchema` instead. */
  export const outboundSchema = Not$outboundSchema;
  /** @deprecated use `Not$Outbound` instead. */
  export type Outbound = Not$Outbound;
}

export function notToJSON(not: Not): string {
  return JSON.stringify(Not$outboundSchema.parse(not));
}

export function notFromJSON(
  jsonString: string,
): SafeParseResult<Not, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Not$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Not' from JSON`,
  );
}

/** @internal */
export const If$inboundSchema: z.ZodType<If, z.ZodTypeDef, unknown> = z.lazy(
  () => JSONSchemaDto$inboundSchema
);

/** @internal */
export type If$Outbound = JSONSchemaDto$Outbound;

/** @internal */
export const If$outboundSchema: z.ZodType<If$Outbound, z.ZodTypeDef, If> = z
  .lazy(() => JSONSchemaDto$outboundSchema);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace If$ {
  /** @deprecated use `If$inboundSchema` instead. */
  export const inboundSchema = If$inboundSchema;
  /** @deprecated use `If$outboundSchema` instead. */
  export const outboundSchema = If$outboundSchema;
  /** @deprecated use `If$Outbound` instead. */
  export type Outbound = If$Outbound;
}

export function ifToJSON(value: If): string {
  return JSON.stringify(If$outboundSchema.parse(value));
}

export function ifFromJSON(
  jsonString: string,
): SafeParseResult<If, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => If$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'If' from JSON`,
  );
}

/** @internal */
export const Then$inboundSchema: z.ZodType<Then, z.ZodTypeDef, unknown> = z
  .lazy(() => JSONSchemaDto$inboundSchema);

/** @internal */
export type Then$Outbound = JSONSchemaDto$Outbound;

/** @internal */
export const Then$outboundSchema: z.ZodType<Then$Outbound, z.ZodTypeDef, Then> =
  z.lazy(() => JSONSchemaDto$outboundSchema);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Then$ {
  /** @deprecated use `Then$inboundSchema` instead. */
  export const inboundSchema = Then$inboundSchema;
  /** @deprecated use `Then$outboundSchema` instead. */
  export const outboundSchema = Then$outboundSchema;
  /** @deprecated use `Then$Outbound` instead. */
  export type Outbound = Then$Outbound;
}

export function thenToJSON(then: Then): string {
  return JSON.stringify(Then$outboundSchema.parse(then));
}

export function thenFromJSON(
  jsonString: string,
): SafeParseResult<Then, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Then$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Then' from JSON`,
  );
}

/** @internal */
export const Else$inboundSchema: z.ZodType<Else, z.ZodTypeDef, unknown> = z
  .lazy(() => JSONSchemaDto$inboundSchema);

/** @internal */
export type Else$Outbound = JSONSchemaDto$Outbound;

/** @internal */
export const Else$outboundSchema: z.ZodType<Else$Outbound, z.ZodTypeDef, Else> =
  z.lazy(() => JSONSchemaDto$outboundSchema);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Else$ {
  /** @deprecated use `Else$inboundSchema` instead. */
  export const inboundSchema = Else$inboundSchema;
  /** @deprecated use `Else$outboundSchema` instead. */
  export const outboundSchema = Else$outboundSchema;
  /** @deprecated use `Else$Outbound` instead. */
  export type Outbound = Else$Outbound;
}

export function elseToJSON(value: Else): string {
  return JSON.stringify(Else$outboundSchema.parse(value));
}

export function elseFromJSON(
  jsonString: string,
): SafeParseResult<Else, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Else$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Else' from JSON`,
  );
}

/** @internal */
export const DependentSchemas$inboundSchema: z.ZodType<
  DependentSchemas,
  z.ZodTypeDef,
  unknown
> = z.lazy(() => JSONSchemaDto$inboundSchema);

/** @internal */
export type DependentSchemas$Outbound = JSONSchemaDto$Outbound;

/** @internal */
export const DependentSchemas$outboundSchema: z.ZodType<
  DependentSchemas$Outbound,
  z.ZodTypeDef,
  DependentSchemas
> = z.lazy(() => JSONSchemaDto$outboundSchema);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DependentSchemas$ {
  /** @deprecated use `DependentSchemas$inboundSchema` instead. */
  export const inboundSchema = DependentSchemas$inboundSchema;
  /** @deprecated use `DependentSchemas$outboundSchema` instead. */
  export const outboundSchema = DependentSchemas$outboundSchema;
  /** @deprecated use `DependentSchemas$Outbound` instead. */
  export type Outbound = DependentSchemas$Outbound;
}

export function dependentSchemasToJSON(
  dependentSchemas: DependentSchemas,
): string {
  return JSON.stringify(
    DependentSchemas$outboundSchema.parse(dependentSchemas),
  );
}

export function dependentSchemasFromJSON(
  jsonString: string,
): SafeParseResult<DependentSchemas, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DependentSchemas$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DependentSchemas' from JSON`,
  );
}

/** @internal */
export const ContentSchema$inboundSchema: z.ZodType<
  ContentSchema,
  z.ZodTypeDef,
  unknown
> = z.lazy(() => JSONSchemaDto$inboundSchema);

/** @internal */
export type ContentSchema$Outbound = JSONSchemaDto$Outbound;

/** @internal */
export const ContentSchema$outboundSchema: z.ZodType<
  ContentSchema$Outbound,
  z.ZodTypeDef,
  ContentSchema
> = z.lazy(() => JSONSchemaDto$outboundSchema);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ContentSchema$ {
  /** @deprecated use `ContentSchema$inboundSchema` instead. */
  export const inboundSchema = ContentSchema$inboundSchema;
  /** @deprecated use `ContentSchema$outboundSchema` instead. */
  export const outboundSchema = ContentSchema$outboundSchema;
  /** @deprecated use `ContentSchema$Outbound` instead. */
  export type Outbound = ContentSchema$Outbound;
}

export function contentSchemaToJSON(contentSchema: ContentSchema): string {
  return JSON.stringify(ContentSchema$outboundSchema.parse(contentSchema));
}

export function contentSchemaFromJSON(
  jsonString: string,
): SafeParseResult<ContentSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContentSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContentSchema' from JSON`,
  );
}

/** @internal */
export const Examples$inboundSchema: z.ZodType<
  Examples,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type Examples$Outbound = {};

/** @internal */
export const Examples$outboundSchema: z.ZodType<
  Examples$Outbound,
  z.ZodTypeDef,
  Examples
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Examples$ {
  /** @deprecated use `Examples$inboundSchema` instead. */
  export const inboundSchema = Examples$inboundSchema;
  /** @deprecated use `Examples$outboundSchema` instead. */
  export const outboundSchema = Examples$outboundSchema;
  /** @deprecated use `Examples$Outbound` instead. */
  export type Outbound = Examples$Outbound;
}

export function examplesToJSON(examples: Examples): string {
  return JSON.stringify(Examples$outboundSchema.parse(examples));
}

export function examplesFromJSON(
  jsonString: string,
): SafeParseResult<Examples, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Examples$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Examples' from JSON`,
  );
}

/** @internal */
export const JSONSchemaDto$inboundSchema: z.ZodType<
  JSONSchemaDto,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: JsonSchemaTypeEnum$inboundSchema.optional(),
  format: JsonSchemaFormatEnum$inboundSchema.optional(),
  title: z.string().optional(),
  description: z.string().optional(),
  default: z.union([z.string(), z.number(), z.boolean()]).optional(),
  const: z.lazy(() => Const$inboundSchema).optional(),
  minimum: z.number().optional(),
  maximum: z.number().optional(),
  exclusiveMinimum: z.boolean().optional(),
  exclusiveMaximum: z.boolean().optional(),
  minLength: z.number().optional(),
  maxLength: z.number().optional(),
  pattern: z.string().optional(),
  minItems: z.number().optional(),
  maxItems: z.number().optional(),
  uniqueItems: z.boolean().optional(),
  items: z.lazy(() => JSONSchemaDto$inboundSchema).optional(),
  required: z.array(z.string()).optional(),
  properties: z.record(z.lazy(() => JSONSchemaDto$inboundSchema)).optional(),
  additionalProperties: z.union([
    z.lazy(() => JSONSchemaDto$inboundSchema),
    z.boolean(),
  ]).optional(),
  enum: z.array(z.string()).optional(),
  allOf: z.array(z.lazy(() => JSONSchemaDto$inboundSchema)).optional(),
  anyOf: z.array(z.lazy(() => JSONSchemaDto$inboundSchema)).optional(),
  oneOf: z.array(z.lazy(() => JSONSchemaDto$inboundSchema)).optional(),
  not: z.lazy(() => JSONSchemaDto$inboundSchema).optional(),
  if: z.lazy(() => JSONSchemaDto$inboundSchema).optional(),
  then: z.lazy(() => JSONSchemaDto$inboundSchema).optional(),
  else: z.lazy(() => JSONSchemaDto$inboundSchema).optional(),
  contentEncoding: z.string().optional(),
  contentMediaType: z.string().optional(),
  dependentRequired: z.record(z.array(z.string())).optional(),
  dependentSchemas: z.record(z.lazy(() => JSONSchemaDto$inboundSchema))
    .optional(),
  $schema: z.string().optional(),
  $id: z.string().optional(),
  contentSchema: z.lazy(() => JSONSchemaDto$inboundSchema).optional(),
  examples: z.array(z.lazy(() => Examples$inboundSchema)).optional(),
  multipleOf: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    "$schema": "dollarSchema",
    "$id": "dollarId",
  });
});

/** @internal */
export type JSONSchemaDto$Outbound = {
  type?: string | undefined;
  format?: string | undefined;
  title?: string | undefined;
  description?: string | undefined;
  default?: string | number | boolean | undefined;
  const?: Const$Outbound | undefined;
  minimum?: number | undefined;
  maximum?: number | undefined;
  exclusiveMinimum?: boolean | undefined;
  exclusiveMaximum?: boolean | undefined;
  minLength?: number | undefined;
  maxLength?: number | undefined;
  pattern?: string | undefined;
  minItems?: number | undefined;
  maxItems?: number | undefined;
  uniqueItems?: boolean | undefined;
  items?: JSONSchemaDto$Outbound | undefined;
  required?: Array<string> | undefined;
  properties?: { [k: string]: JSONSchemaDto$Outbound } | undefined;
  additionalProperties?: JSONSchemaDto$Outbound | boolean | undefined;
  enum?: Array<string> | undefined;
  allOf?: Array<JSONSchemaDto$Outbound> | undefined;
  anyOf?: Array<JSONSchemaDto$Outbound> | undefined;
  oneOf?: Array<JSONSchemaDto$Outbound> | undefined;
  not?: JSONSchemaDto$Outbound | undefined;
  if?: JSONSchemaDto$Outbound | undefined;
  then?: JSONSchemaDto$Outbound | undefined;
  else?: JSONSchemaDto$Outbound | undefined;
  contentEncoding?: string | undefined;
  contentMediaType?: string | undefined;
  dependentRequired?: { [k: string]: Array<string> } | undefined;
  dependentSchemas?: { [k: string]: JSONSchemaDto$Outbound } | undefined;
  $schema?: string | undefined;
  $id?: string | undefined;
  contentSchema?: JSONSchemaDto$Outbound | undefined;
  examples?: Array<Examples$Outbound> | undefined;
  multipleOf?: number | undefined;
};

/** @internal */
export const JSONSchemaDto$outboundSchema: z.ZodType<
  JSONSchemaDto$Outbound,
  z.ZodTypeDef,
  JSONSchemaDto
> = z.object({
  type: JsonSchemaTypeEnum$outboundSchema.optional(),
  format: JsonSchemaFormatEnum$outboundSchema.optional(),
  title: z.string().optional(),
  description: z.string().optional(),
  default: z.union([z.string(), z.number(), z.boolean()]).optional(),
  const: z.lazy(() => Const$outboundSchema).optional(),
  minimum: z.number().optional(),
  maximum: z.number().optional(),
  exclusiveMinimum: z.boolean().optional(),
  exclusiveMaximum: z.boolean().optional(),
  minLength: z.number().optional(),
  maxLength: z.number().optional(),
  pattern: z.string().optional(),
  minItems: z.number().optional(),
  maxItems: z.number().optional(),
  uniqueItems: z.boolean().optional(),
  items: z.lazy(() => JSONSchemaDto$outboundSchema).optional(),
  required: z.array(z.string()).optional(),
  properties: z.record(z.lazy(() => JSONSchemaDto$outboundSchema)).optional(),
  additionalProperties: z.union([
    z.lazy(() => JSONSchemaDto$outboundSchema),
    z.boolean(),
  ]).optional(),
  enum: z.array(z.string()).optional(),
  allOf: z.array(z.lazy(() => JSONSchemaDto$outboundSchema)).optional(),
  anyOf: z.array(z.lazy(() => JSONSchemaDto$outboundSchema)).optional(),
  oneOf: z.array(z.lazy(() => JSONSchemaDto$outboundSchema)).optional(),
  not: z.lazy(() => JSONSchemaDto$outboundSchema).optional(),
  if: z.lazy(() => JSONSchemaDto$outboundSchema).optional(),
  then: z.lazy(() => JSONSchemaDto$outboundSchema).optional(),
  else: z.lazy(() => JSONSchemaDto$outboundSchema).optional(),
  contentEncoding: z.string().optional(),
  contentMediaType: z.string().optional(),
  dependentRequired: z.record(z.array(z.string())).optional(),
  dependentSchemas: z.record(z.lazy(() => JSONSchemaDto$outboundSchema))
    .optional(),
  dollarSchema: z.string().optional(),
  dollarId: z.string().optional(),
  contentSchema: z.lazy(() => JSONSchemaDto$outboundSchema).optional(),
  examples: z.array(z.lazy(() => Examples$outboundSchema)).optional(),
  multipleOf: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    dollarSchema: "$schema",
    dollarId: "$id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace JSONSchemaDto$ {
  /** @deprecated use `JSONSchemaDto$inboundSchema` instead. */
  export const inboundSchema = JSONSchemaDto$inboundSchema;
  /** @deprecated use `JSONSchemaDto$outboundSchema` instead. */
  export const outboundSchema = JSONSchemaDto$outboundSchema;
  /** @deprecated use `JSONSchemaDto$Outbound` instead. */
  export type Outbound = JSONSchemaDto$Outbound;
}

export function jsonSchemaDtoToJSON(jsonSchemaDto: JSONSchemaDto): string {
  return JSON.stringify(JSONSchemaDto$outboundSchema.parse(jsonSchemaDto));
}

export function jsonSchemaDtoFromJSON(
  jsonString: string,
): SafeParseResult<JSONSchemaDto, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => JSONSchemaDto$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'JSONSchemaDto' from JSON`,
  );
}
